---
title: Docker
createTime: 2025/07/08 23:54:26
permalink: /memorandum/Docker/
---



## 概述

&emsp;&emsp;Docker 是一个开源的应用容器引擎，基于 Go 语言并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。

Docker 的优势：

- **轻量级高效**：比虚拟机占用更少资源，秒级启动时间
- **可移植性**：在各种云平台间迁移

## Linux 安装 Docker

官方帮助文档：https://docs.docker.com/engine/install/centos/

### 安装命令

1. 卸载之前的docker

   ```cmd
   sudo yum remove docker \
         docker-client \
         docker-client-latest \
         docker-common \
         docker-latest \
         docker-latest-logrotate \
         docker-logrotate \
         docker-engine
   ```

2. 需要的安装包

   ```yml
   yum install -y yum-utils
   ```

3. 设置镜像的仓库

   ```yml
   # 国外的，不推荐，linux命令直接报错：连接docker官网超时
   yum-config-manager \
       --add-repo \
       https://download.docker.com/linux/centos/docker-ce.repo
       
   # 国内阿里云
   yum-config-manager \
       --add-repo \
       https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
   ```

4. 更新yum软件包索引

   ```cmd
   yum makecache 
   ```

5. 安装docker相关的 docker-ce 社区版 而ee是企业版

   ```cmd
   yum install docker-ce docker-ce-cli containerd.io
   ```

6. 启动docker

   ```cmd
   service docker start
   ```

7. 查看docker状态

   ```yml
   service docker status
   ```

8. 使用docker version查看是否安装成功

   ```yml
   docker version
   ```

9. 设置docker开机自启动

   ```yml
   systemctl enable docker.service
   ```

10. 查看docker是否开机自启动成功

    ```yml
    systemctl is-enabled docker
    ```

### 阿里云镜像加速

```yml
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://svctvo40.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
```

## 核心概念

### 镜像

拉取镜像：

```shell
docker pull 镜像名:镜像版本
```

### 容器

查看运行中的容器

```shell
docker ps 参数
```

常用参数：

1. `-a, --all`: 显示所有容器，包括停止的容器。
2. `-q, --quiet`: 只显示容器 ID。
3. `-l, --latest`: 显示最近创建的一个容器，包括所有状态。

举例：

```shell
# 查看所有正在运行的容器
docker ps

# 查看所有的容器
docker ps -a
```

创建容器

```shell
docker run 参数
```

常见参数说明：

- `--name`: 给容器指定一个名称
- `-p`: 端口映射，格式为 `host_port:container_port`
- `--env` 或 `-e`: 设置环境变量。
- `-d`: 后台运行容器并返回容器 ID
- `-v`: 挂载卷，格式为 `host_dir:container_dir`。

启动、停止、重启容器语法：

```shell
docker start/stop/restart 容器名
```

- 删除容器：

```shell
# 删除单个容器
docker rm 容器名称(或容器id)

# 删除多个容器
docker rm 容器名称(或容器id) 容器名称(或容器id) 容器名称(或容器id)

# 删除所有的容器
docker rm $(docker ps -a -q)
```

### 日志

- 语法：

```shell
docker logs 参数 镜像名称
```

常见的参数：

- `--tail`: 仅显示日志的最后部分，例如 `--tail 10` 显示最后 10 行
- `-t, --timestamps`: 显示日志时间戳
- `--details`: 显示提供给日志的额外详细信息。

例子：

```shell
# 显示容器日志
docker logs my_container

# 显示最后 10 行的日志
docker logs --tail 10 my_container

# 显示带有时间戳的日志
docker logs -t my_container
```

## Docker Compose

### 定义

Docker Compose 是一个用于**定义和运行多容器 Docker 应用**的工具。通过一个 YAML 文件（`docker-compose.yml`），我们可以配置应用程序的所有服务，然后使用单个命令创建和启动所有服务。

**主要功能：**

- 使用 YAML 文件管理多容器应用
- 一键启动/停止整个应用栈
- 服务间网络和卷管理
- 环境变量配置
- 服务依赖关系管理

**典型应用场景：**

- 开发环境搭建
- 自动化测试环境
- 单主机部署
- 微服务应用

### 安装

#### Linux

```shell
# 下载最新版本的 Docker Compose
sudo curl -L "https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose

# 添加可执行权限
sudo chmod +x /usr/local/bin/docker-compose

# 验证安装
docker-compose --version
# 应输出：Docker Compose version v2.23.0
```

#### Windows/macOS

Windows 和 macOS 的 Docker Desktop 已包含 Docker Compose，无需单独安装

### 文件结构

```yaml
version: "3.9"  # Compose 文件格式版本

services:        # 定义所有服务
  web:           # 服务名称，web服务
    image: nginx:alpine  # 使用的镜像
    ports:
      - "80:80"  # 端口映射
    volumes:
      - ./html:/usr/share/nginx/html  # 卷挂载

  db:			# 数据库服务
    image: postgres:15
    environment:  # 环境变量
      POSTGRES_PASSWORD: example

volumes:         # 定义卷
  db-data:       # 卷名称
```

### 常用命令

| 命令                         | 说明                     |
| :--------------------------- | :----------------------- |
| `docker-compose up`          | 创建并启动所有服务       |
| `docker-compose up -d`       | 在后台运行服务           |
| `docker-compose down`        | 停止并移除所有容器、网络 |
| `docker-compose ps`          | 查看运行中的服务         |
| `docker-compose logs`        | 查看服务日志             |
| `docker-compose logs -f web` | 实时查看 web 服务日志    |
| `docker-compose build`       | 构建或重新构建服务镜像   |
| `docker-compose start`       | 启动已存在的服务         |
| `docker-compose stop`        | 停止运行中的服务         |
| `docker-compose restart`     | 重启服务                 |
| `docker-compose exec web sh` | 进入 web 服务的容器      |
| `docker-compose pull`        | 拉取服务的最新镜像       |
| `docker-compose config`      | 验证 Compose 文件格式    |

### 实践

```yaml
# docker-compose.yml
version: "3.9"

services:
  db:
    image: mysql:8.0
    volumes:
      - db_data:/var/lib/mysql
    environment:
      MYSQL_ROOT_PASSWORD: rootpass
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpresspass

  wordpress:
    image: wordpress:latest
    ports:
      - "8000:80"
    environment:
      WORDPRESS_DB_HOST: db
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpresspass
      WORDPRESS_DB_NAME: wordpress
    depends_on:
      - db

volumes:
  db_data:
```

启动应用：

```shell
docker-compose up -d
```

访问： [http://localhost:8000](http://localhost:8000/)

## 常用容器

### Nginx

```shell
docker pull nginx
```

创建挂载目录

```shell
# 创建挂载目录

mkdir -p /home/nginx/conf
mkdir -p /home/nginx/log
mkdir -p /home/nginx/html
mkdir -p /home/nginx/my_website


```

```
# 创建配置文件
touch /home/nginx/conf/nginx.conf

# 编辑文件
vim /home/nginx/conf/nginx.conf
```



```
user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;

# 必须包含这个 events 块，否则会报错
events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '\$remote_addr - \$remote_user [\$time_local] "\$request" '
                      '\$status \$body_bytes_sent "\$http_referer" '
                      '"\$http_user_agent" "\$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    keepalive_timeout  65;

    # 包含 conf.d 目录下的所有子配置
    include /etc/nginx/conf.d/*.conf;
}
```

创建容器

```shell
docker run --name nginx \
-p 80:80 \
-v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \
-v /home/nginx/conf/conf.d:/etc/nginx/conf.d \
-v /home/nginx/log:/var/log/nginx \
-v /home/nginx/html:/usr/share/nginx/html \
-v /home/nginx/my_website:/usr/share/nginx/my_website \
-d nginx:latest
```



### RabbitMQ

创建文件夹

```
mkdir -p /home/docker/rabbitmq


```

拉取镜像

```
docker pull rabbitmq:management
```

运行容器

```shell
docker run -d --name rabbitmq \
-p 15672:15672 \
-p 5672:5672 \
-v /home/docker/rabbitmq:/var/lib/rabbitmq \
-e RABBITMQ_DEFAULT_USER=admin \
-e RABBITMQ_DEFAULT_PASS=admin123 \
rabbitmq:management
```

### ES

#### ElasticSearch

拉取镜像

```shell
docker pull elasticsearch:7.17.2
```

创建映射文件夹

```shell
mkdir -p /home/elasticsearch/config
mkdir -p /home/elasticsearch/data

chmod -R 777 /home/elasticsearch
```

写入配置文件

```shell
echo "http.host: 0.0.0.0">>/home/elasticsearch/config/elasticsearch.yml
```

创建容器

```shell
docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \
-e "discovery.type=single-node" \
-e ES_JAVA_OPTS="-Xms64m -Xmx128m" \
-v /home/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \
-v /home/elasticsearch/data:/usr/share/elasticsearch/data \
-v /home/elasticsearch/plugins:/usr/share/elasticsearch/plugins \
-d elasticsearch:7.17.2
```

访问 ip 地址:9200

![image-20260110144842224](https://img.haipeng-lin.cn/1768027729169.png)

#### kibana

拉取镜像

```shell
docker pull kibana:7.17.2
```

创建容器

```shell
docker run --name kibana -d \
 -e ELASTICSEARCH_HOSTS=http://8.155.33.36:9200 \
-e "NODE_OPTIONS=--max-old-space-size=512" \
 -p 5601:5601 \
 kibana:7.17.2
```

汉化，由于已经创建好了容器，无法再配置挂载目录，只能通过复制容器的文件到本地，修改完，再复制回去

```shell
docker cp kibana:/usr/share/kibana/config/kibana.yml ./kibana.yml
```

文件末尾加入内容

```yml
i18n.locale: "zh-CN"
```

再复制回去

```shell
docker cp ./kibana.yml kibana:/usr/share/kibana/config/kibana.yml
```

重启容器









```
user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    # 修正：去掉反斜杠，确保日志记录正确
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    keepalive_timeout  65;

    # 包含子配置（建议将具体的 server 逻辑放在 conf.d 下的文件里）
    include /etc/nginx/conf.d/*.conf;

    # 修正：将 server 块移入 http 块内部
    server {
        listen 80;
        server_name _;
     
        root /usr/share/nginx/html;
        index index.html;
     
        location / {
            try_files $uri $uri/ =404;
        }
    }
}
```





```
server{
  listen 88;
  server_name 154.12.46.41;
  root /usr/share/nginx/my_website/vuepress;
  
  location /baidu-api/ {
        # 重写路径：去掉开头的 /baidu-api
        rewrite ^/baidu-api/(.*)$ /$1 break;

        # 目标接口域名
        proxy_pass https://openapi.baidu.com;

        # 关键：伪造请求头，欺骗百度服务器
        proxy_set_header Host openapi.baidu.com;
        proxy_set_header Origin https://api.baidu.com;
        proxy_set_header Referer https://api.baidu.com;

        # 传递客户端真实 IP
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # 解决 HTTPS 代理可能出现的 SNI 问题
        proxy_ssl_server_name on;
    }
}

```

### PostgreSQL

拉取镜像

```shell
docker pull postgres:18.1
```

创建容器

```shell
mkdir /home/postgresql/data
```

```shell
docker run --name postgresql \
-p 5432:5432 \
-e POSTGRES_PASSWORD=20020307 \
-e POSTGRES_USER=haipeng-lin
-e POSTGRES_DB=testdb
-v /home/postgresql/data:/var/lib/postgresql/data
-d postgres
```

