---
title: 工厂方法模式
createTime: 2025/01/17 12:04:37
permalink: /computer-basics/somyvfum/
---



## 1.介绍

- 定义：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

- 解决：==**创建者和调用者的耦合**==，那么代码层面其实就是取消对new的使用。

- 场景：需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现

- 三种创建工厂模式的方法：

  - 简单工厂模式

  - 工厂方法模式

  - 抽象方法模式


- 四种角色

  - 抽象产品：定义了产品的共同接口或抽象类。它可以是具体产品类的父类或接口，规定了产品对象的共同方法。

  - 具体产品：实现了抽象产品接口，定义了具体产品的特定行为和属性。

  - 抽象工厂：声明了创建产品的抽象方法，可以是接口或抽象类。它可以有多个方法用于创建不同类型的产品。

  - 具体工厂：实现了抽象工厂接口，负责实际创建具体产品的对象。


## 2.举例

### 2.1 简单工厂模式

#### 2.1.1 模式图

<img src="https://img.haipeng-lin.cn/20251003073916.jpeg" alt="在这里插入图片描述" style="zoom:33%;" />


#### 2.1.2 代码

- Phone接口

```java
public interface Phone {
    void getBrand();
}
```

- Meizu品牌类

```java
public class Meizu implements Phone {
    @Override
    public void getBrand() {
        System.out.println("魅族");
    }
}
```

- Xiaomi品牌类

```java
public class Xiaomi implements Phone {
    @Override
    public void getBrand() {
        System.out.println("小米");
    }
}
```

- PhoneFactory工厂类

```java
public class PhoneFactory{
    public static Phone getPhone(String phone){
        if("小米".equals(phone)){
           return new Xiaomi();
        }else if ("魅族".equals(phone)){
          return new Meizu();
        }else {
            return null;
        }
    }
}
```

- 消费者类

```java
public class Customer {
    public static void main(String[] args) {
        PhoneFactory.getPhone("Xiaomi").getBrand();
        PhoneFactory.getPhone("Meizu").getBrand();
    }
}
```

#### 2.1.3 遇到的问题

随着手机品牌增多，工厂生产也需要对应的增加，工厂内部就需要不断的调整。

从代码层面——对内部代码的PhoneFactory工厂类需要增加（**也就是需要修改内部代码**：那么就会违反OOP原则—开闭原则)：一个软件实体应当对扩展开放，对修改关闭）。那怎么解决呢？

<img src="https://img.haipeng-lin.cn/20251003073920.png" alt="image-20240205105534859" style="zoom:50%;" />

### 2.2 工厂方法模式

#### 2.2.1 模式图

<img src="https://img.haipeng-lin.cn/20251003073926.png" alt="image-20240205105534859" style="zoom:50%;" />

#### 2.2.2 代码

- Phone接口

```java
public interface Phone {
    void getBrand();
}
```

- PhoneFactory接口

```java
public interface PhoneFactory {
    Phone getPhone();
}
```

- Xiaomi品牌类

```java
public class Xiaomi implements Phone {
    @Override
    public void getBrand() {
        System.out.println("小米");
    }
}
```

- XiaomiFactory工厂类

```java
public class XiaomiFactory implements PhoneFactory {
    @Override
    public Phone getPhone() {
        return new Xiaomi();
    }
}
```

- MeiZu品牌类

```java
public class MeiZu implements Phone {
    @Override
    public void getBrand() {
        System.out.println("魅族");
    }
}
```

- MeiZuFactory工厂类

```java
public class MeizuFactory implements PhoneFactory{
    @Override
    public Phone getPhone() {
        return new Meizu();
    }
}
```

- 消费者

```java
public class Customer {
    public static void main(String[] args) {
        Phone xiaomi = new XiaomiFactory().getPhone();
        Phone meizu = new MeizuFactory().getPhone();
        xiaomi.getBrand();
        meizu.getBrand();
    }
}
```

#### 2.2.3 优缺点

工厂方法模式解决简单工厂模式是需要付出代价的！

看到上图工厂方法模式图里==**新增用虚线画的Huawei品牌，每新增一个品牌就需要增加，对应新的工厂**==，会发现需要花费很大的成本，现在才三个新的品牌，那么等到十个、一百个的时候就会变得更加的复杂和难以维护。

## 3.区分三种工厂模式

|      | 简单工厂                                                     | 工厂方法                                                     | 抽象工厂 |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 描述 | 只有一个工厂，该工厂根据传入的参数决定创建哪个类的实例       | 有多个工厂，每个工厂负责生产对应一个产品                     |          |
| 优点 | 简化客户端代码，不需要关心对象的具体类或构造方式             | 符合开闭原则<br />减少代码耦合，客户端不需要直接依赖具体的产品类，而是依赖于抽象的工厂接口 |          |
| 缺点 | 工厂类过于庞大<br />违反开闭原则（即对扩展打开，修改关闭）<br /> | 不适合产品变化频繁的场景<br />复杂性增加<br />               |          |
| 应用 | 实际去开发中会发现比较常用<br />不需要暴露产品类的细节       | 产品系列复杂、产品类型变化不频繁                             |          |

## 4.应用

- 核心应用：不同条件下创建不同实例时。方法是让子类实现工厂接口。

- 使用场景
  - 需要生成对象的地方
  - 需要灵活的、可扩展的框架
  - ==数据库访问、数据库可能变化时==

- 应用实例
  - 需要一辆汽车，直接从工厂里面提货，不用去管这辆车是怎么做出来的