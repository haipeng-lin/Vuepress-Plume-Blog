---
title: 单例模式
createTime: 2025/01/17 12:03:52
permalink: /computer-basics/95b3b2i4/
---



## 1.定义

采取一定的方法保证在整个的软件系统中，==**对某个类只能存在一个对象实例**==，并且该类只提供一个取得其对象实例的方法(静态方法)

简要定义：**类在内存中只能存在一个实例对象**

## 2.实现方法

共有5种单例模式创建方法，分别为饿汉式、懒汉式、双重检验锁、静态内部类、以及枚举创建类对象方法

其中饿汉式、懒汉式、双重检验锁是最常见的3种方式

### 2.1 饿汉式

> 通俗理解：不饿就点外卖

#### 2.1.1 定义

> 类内部直接创建出类的实例，然后用private私有化，对外只用静态方法（返回该实例）暴露

#### 2.1.2 创建步骤

> - 构造器私有化
> - 类的内部创建对象（直接创建对象了）
> - 向外暴露一个静态的公共方法：返回该类的对象

#### 2.1.3 举例

该类的实例有两种创建方法：静态成员变量、静态代码块

> 静态成员变量

``` java
class Singleton {
	//私有化构造器
	private Singleton() {	
	}
	//内部创建对象实例
	private final static Singleton instance = new Singleton();
	//对外公有的静态方法
	public static Singleton getInstance() {
		return instance;
	}
}
```

> 静态代码块

```java
class Singleton {  //静态代码块
	//私有化构造器
	private Singleton() {}
	//内部创建对象实例
	private  static Singleton instance;
	static { // 在静态代码块中，创建单例对象
		instance = new Singleton();
	}
	//对外公有的静态方法
	public static Singleton getInstance() {
		return instance;
	}
}
```

#### 2.1.4 小结

| 优点                                                 | 缺点                                                         |
| :--------------------------------------------------- | :----------------------------------------------------------- |
| 写法简单，在类装载的时完成实例化，避免了线程同步问题 | 类装载时完成实例化，没有达到LazyLoading的效果，若该实例从未使用，则会造成内存浪费 |

### 2.2 懒汉式

> 通俗理解：饿了才点外卖

#### 2.2.1 定义

> 在需要调用的时候再创建类的实例化

#### 2.2.2 创建步骤

> - 构造器私有化
> - 向外暴露一个静态的公共方法：里面创建该类的对象

#### 2.2.3 举例

该类的实例有两种创建方法：线程不安全和线程安全

> 线程不安全：起到了懒加载效果，但是只能在单线程使用，多线程会不安全，因为当多个线程并发同时判断instance为空时，就会相应的实例化多个对象。

```java
class Singleton { //线程不安全
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {  //调用时才实例化对象，懒汉式
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

> 线程安全：使用synchronized关键字上锁。 这样虽然解决了线程安全，但其实实例化操作只做一次，而获取实例(即getInstance)的操作是很多次的，把调用的方法加上同步，会大大降低效率。

```java
class Singleton { //线程安全
    private static Singleton instance;
    private Singleton() {}
    //synchronized同步处理
    public static synchronized Singleton getInstance() {
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

#### 2.2.4 小结

| 优点                                   | 缺点                                                         |
| :------------------------------------- | :----------------------------------------------------------- |
| 优点：第一次调用才初始化，避免内存浪费 | 必须加锁 synchronized 才能保证单例，但加锁会影响效率<br/>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 |

### 2.3 双重检验锁

#### 2.3.1 定义

##### （1）由来

懒汉式使用线程安全的方法，使用了synchronized关键字，并且加锁其实只需要在第一次初始化的时候用到，之后的调用都没必要再进行加锁。来创建类的对象效率低

##### （2）解决及步骤

先判断对象是否已经被初始化，再决定要不要加锁。

> - 检查变量是否被初始化(不去获得锁)，如果已被初始化则立即返回。
> - 获取锁。
> - 再次检查变量是否已经被初始化，如果还没被初始化就初始化一个对象。

```java
public class Singleton {
    private static Singleton uniqueSingleton;

    private Singleton() {
    }

    public Singleton getInstance() {
        if (null == uniqueSingleton) {
            synchronized (Singleton.class) {
                if (null == uniqueSingleton) {
                    uniqueSingleton = new Singleton();   // error
                }
            }
        }
        return uniqueSingleton;
    }
}

```

双重检查：如果多个线程同时了通过了第一次检查，并且其中一个线程首先通过了第二次检查并实例化了对象，那么==剩余通过了第一次检查的线程就不会再去实例化对象==。

##### （3）隐患

上述写法看似解决了问题，但是有个很大的隐患。实例化对象的那行代码（标记为error的那行），实际上可以分解成以下三个步骤：

1. 分配内存空间
2. ==初始化对象==
3. ==将对象指向刚分配的内存空间==

但是有些编译器为了性能的原因，可能会将第二步和第三步进行**重排序**，顺序就成了：

1. 分配内存空间
2. ==将对象指向刚分配的内存空间==
3. ==初始化对象==

现在考虑重排序后，两个线程发生了以下调用：

| Time | Thread A                        | Thread B                                        |
| :--- | :------------------------------ | :---------------------------------------------- |
| T1   | 检查到`uniqueSingleton`为空     |                                                 |
| T2   | 获取锁                          |                                                 |
| T3   | 再次检查到`uniqueSingleton`为空 |                                                 |
| T4   | 为`uniqueSingleton`分配内存空间 |                                                 |
| T5   | 将`uniqueSingleton`指向内存空间 |                                                 |
| T6   |                                 | 检查到`uniqueSingleton`不为空                   |
| T7   |                                 | 访问`uniqueSingleton`（此时对象还未完成初始化） |
| T8   | 初始化`uniqueSingleton`         |                                                 |

在这种情况下，T7时刻线程B对`uniqueSingleton`的访问，访问的是一个**初始化未完成**的对象。

#### 2.3.2 正确举例

> 注意：需要用到关键字volatile，防止指令重排。如果不用volatile关键字，就会和线程不安全情形一样，在if判断那会有并发。

```java
class Singleton { //双重检查
	private static volatile Singleton instance;
	private Singleton() {}
	public static Singleton getInstance() {
		if(instance == null) { //判断是否实例化
			synchronized (Singleton.class) {
				if(instance == null) {
					instance = new Singleton();
				}
			}
		}
		return instance; //否则直接return
	}
}
```

#### 2.3.3 小结

既实现了懒加载，又保证了线程安全。

### 2.4 静态内部类

#### 2.4.1 定义

静态内部类在外部类装载时不会实例化，当调用的时候才会装载并实例化，且JVM保证了其装载时的线程安全性。也能保证懒加载和线程安全，有点像自带版的双重检查。

```java
class Singleton {
	private static volatile Singleton instance;
	private Singleton() {}
	//静态内部类,包含一个静态属性：Singleton
	private static class SingletonInstance {
		private static final Singleton INSTANCE = new Singleton(); 
	}
	//对外公有的静态方法，直接返回SingletonInstance.INSTANCE
	public static synchronized Singleton getInstance() {
		return SingletonInstance.INSTANCE;
	}
}
```

### 2.5 枚举

其实，使用枚举也能实现单例模式，不仅能避免多线程同步问题，也能防止反序列化重新创建新的对象。

```java
enum Singleton {
	INSTANCE; //属性
	public void say() {
		System.out.println("记得三连~");
	}
}
```

## 3.小结

1、当一个类的对象只需要或者只可能有一个时，应该考虑单例模式。

2、如果一个类的实例应该在JVM初始化时被创建出来，应该考虑使用饿汉式。

3、如果一个类的实例不需要预先被创建，也许这个类的实例并不一定能用得上，也许这个类的实例创建过程比较耗费时间，也许就是真的没必要提前创建。那么应该考虑懒汉式。

4、在使用懒汉式单例的时候，应该考虑到线程的安全性问题。