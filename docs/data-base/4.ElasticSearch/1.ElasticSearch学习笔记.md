---
title: ElasticSearch学习笔记
createTime: 2025/01/16 11:20:25
permalink: /data-base/ElasticSearch/Elasti57xmp4epcSearch学习笔记/
---

## 1.介绍

### 1.1 ES 简介

&emsp;&emsp;Elasticsearch 是一个分布式、RESTful 风格的数据搜索和分析引擎

> **ElasticSearch特点：**

1. 分布式的文件存储，**每个字段都被索引**且可用于搜索。
2. **分布式**的实时分析搜索引擎，**海量数据**下近实时秒级响应。
3. 简单的**restful api**，天生的兼容多语言开发。
4. **易扩展**，处理PB级结构化或非结构化数据

> **ElasticSearch缺点：**

1. 由于 Elasticsearch 需要处理大量的数据，因此需要**较高的硬件性能**和存储空间。
2. 由于 Elasticsearch 是一个分布式系统，可能存在**数据一致性**问题

> **适用场景：**

1. 日志分析：Elasticsearch 可以快速地搜索和分析大量的日志数据。
2. 搜索引擎：Elasticsearch 可以作为搜索引擎用于搜索和排序数据。
3. 数据分析：Elasticsearch 可以用于数据分析，支持聚合和分析数据。
4. 地理位置搜索：Elasticsearch 支持地理位置搜索，可以用于地图应用等。

### 1.2 ES 与 Solr 对比

1. Solr是Apache Lucene项目的开源**企业搜索平台**。其主要功能包括**全文检索**、命中标示、分面搜索、动态聚类、数据库集成，以及富文本（如Word、PDF）的处理；Solr是高度可扩展的，并提供了分布式搜索和索引复制功能
2. 当单纯的对**已有数据**进行搜索时，Solr更快；当实时建立索引时，Solr会产生io阻塞，查询性能较差
3. 随着**数据量的增加**，Solr的搜索效率会变得更**低**，而Elasticsearch却没有明显的变化。

### 1.3 ES 与 MySQL 对比

结论：ElasticSearch比MySQL查询快，原因如下：

- **基于分词的全文检索：**
  - 例如select * from test where name like ‘%张三%’，对于mysql来说，因为索引失效，会进行全表检索；
  - 对es而言分词后，每个字都可以利用 FST 高速找到倒排索引的位置，并迅速获取文档id列表，大大的提升了性能，减少了磁盘IO

- **精确检索：**
  - 进行精确检索，有些时候可能mysql要快一些，当mysql的非聚合索引引用上了聚合索引，无需回表，则速度上可能更快；
  - es还是通过FST找到倒排索引的位置比获取文档id列表，再根据文档id获取文档并根据相关度进行排序
  - 但是es还有个优势，就是es即天然的分布式能够在大量数据搜索时可以通过分片降低检索规模，并且可以通过并行检索提升效率，用filter时，更是可以直接跳过检索直接走缓存

### 1.4 ES基本概念

![img](https://img.haipeng-lin.cn/20251003074425.jpeg)

#### 1.4.1 Index

Index，即索引，关键词有两种用法，可用作动词、或者名词

1. 动词，相当于 MySQL 中的 insert 、插入
2. 名词，相当于 MySQL 中的 Database 、数据库

#### 1.4.2 Type

在Index（索引）中,可以定义一个或多个类型,每种类型的数据放一起；类似于MySQL中数据库中可以定义一个或多个表（Table）;

ES7、8版本差异：
1. Elasticsearch 7. X URL中**的 type 参数为可选**。比如，索引一个文档不再要求提供文档类型。
2. Elasticsearch 8.X 不再支持 URL中的type参数。ElasticSearch8开始，将索引从多类型迁移到单类型，每种类型文档一个独立索引
3. **原因**：Elasticsearch是基于Lucene开发的搜索引擎，而**ES中不同type下名称相同的 filed 最终在Lucene中的处理方式是一样的**。不同type中的相同字段名称就会在处理中出现冲突的情况，**导致Lucene处理效率下降**，去掉type就是为了提高ES处理数据的效率。

#### 1.4.3 Document

1. 保存到某个索引下,某种类型的一个数据，文档是 JSON 格式的
2. 一个Document就像是MySQL中某个表的一条记录

### 1.5 倒排索引

#### 1.5.1 正排/倒排

- **正排**：
  - 存储 `doc_id`=>`当前文档包含的所有词项` 的映射。
  - 优点及应用：快速的查找**某个文档里包含哪些词项**，适合做聚合
- **倒排**：
  - 存储 `词项`=>`包含当前词项的doc_id的列表` 的映射。
  - 优点及应用：可以快速查找包含某个词项的文档有哪些，适合做查询

#### 1.5.2 例子

如下所示，有5个文档，以及对应的文档 id ：1、红海行动 2、探索红海行动 3、红海特别行动 4、红海记录篇 5、特工红海特别探索

正向索引的存储：

| 文档id | 记录                   |
| ------ | ---------------------- |
| 1      | 红海、行动             |
| 2      | 探索、红海、行动       |
| 3      | 特别、红海、行动       |
| 4      | 红海、记录             |
| 5      | 特工、红海、特别、探索 |

倒排索引的存储：

| 词     | 记录          |
| ------ | ------------- |
| 红海   | 1、2、3、4、5 |
| 行动   | 1、2、3       |
| 探索   | 2、5          |
| 特别   | 3、5          |
| 记录篇 | 4             |
| 特工   | 5             |

#### 1.5.3 工作流程：

- **分词**：首先，文本被分析器（Analyzer）处理，将文档拆分成单词或术语（Token）。这个过程包括去除标点符号、转换为小写、分词等步骤。
- **创建词项文档矩阵**：接下来，系统为每个独一无二的词项（Term）建立一个记录，这个记录包含了该词项出现在哪些文档中，以及在每篇文档中的位置。这个过程生成了一个倒排列表（Posting List），每个词项都有一个这样的列表。
- **压缩与优化**：倒排列表可能会占用大量空间，因此会采用各种压缩技术来减少存储需求。同时，为了提高查询效率，倒排索引还会进行一些优化，比如分块存储、使用跳跃指针快速定位等。
- **查询处理**：当用户发起搜索请求时，Elasticsearch 会查找倒排索引中对应的词项，迅速获取到包含这些词项的所有文档ID列表。然后，根据相关性评分算法（如TF-IDF、BM25等）对这些文档进行排序，最后返回最相关的文档给用户。

## 2.安装ElasticSearch

### 2.1 拉取镜像

elasticsearch 与 kibana 版本是同步的

```yml
docker pull elasticsearch:7.4.2 #存储和检索数据
docker pull kibana:7.4.2 #可视化检索数据
```

### 2.2 创建容器

#### 2.1.1 创建 ElasticSearch 实例

```yml
#先将es的数据与配置与需要映射的文件夹创建好
mkdir -p /mydata/elasticsearch/config
mkdir -p /mydata/elasticsearch/data
#配置es地址
echo "http.host: 0.0.0.0" >> /mydata/elasticsearch/config/elasticsearch.yml
#保证权限
chmod -R 777 /mydata/elasticsearch/ 
#创建并启动实例
docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \
-e "discovery.type=single-node" \-e ES_JAVA_OPTS="-Xms64m -Xmx512m" \
-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \
-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \
-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \
-d elasticsearch:7.4.2
```

- 注意：-e ES_JAVA_OPTS="-Xms64m -Xmx256m" \ 测试环境下， 设置 ES 的初始内存和最大内存， 否则会导致占用内存过多

- 效果：

![image-20231125163451134](https://img.haipeng-lin.cn/20251003074435.png)

- ES的9200和9300端口区别

	- 9200作为 Http 协议，主要用于外部通讯

	- 9300作为 Tcp 协议，jar之间就是通过tcp协议通讯 .ES集群之间是通过9300进行通讯

> 测试是否创建成功
>
> 192.168.234.128:9200 虚拟机地址+9200
>
> 记得防火墙开放9200端口

![image-20231125163328991](https://img.haipeng-lin.cn/20251003074440.png)

#### 2.1.2 创建 Kibana 实例

```yml
docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.234.128:9200 -p 5601:5601 \
-d kibana:7.4.2
```

> 测试是否创建成功
>
> 192.168.234.128:5601

<img src="https://img.haipeng-lin.cn/20251003074447.png" alt="image-20231125164601714" style="zoom: 33%;" />

### 2.3 设置 ES 和kibana自启动

> 先不设置，担心内存不够

```yml
# 设置es在docker开启的时候启动
docker update elasticsearch --restart=always
# 设置Kibana在docker开启的时候启动
docker update kibana --restart=always
```

## 3.初级检索

### 3.1 查看节点/索引

```yml
#查看所有节点
GET /_cat/nodes

#查看所有节点
GET /_cat/health

#查看主节点
GET /_cat/master

#查看所有索引——show databases;
GET /_cat/indices
```

### 3.2 索引文档

#### 3.2.1 PUT 方法

**保存一个数据， 保存在哪个索引的哪个类型下， 指定用哪个唯一标识**

![image-20231125170734843](https://img.haipeng-lin.cn/20251003074453.png)

#### 3.2.2 POST 方法

![image-20231125171504137](https://img.haipeng-lin.cn/20251003074458.png)

#### 3.2.3 PUT 和 POST 的区别

- 相同

	- PUT 与 POST 都可以新增与修改文档

	- PUT 与 POST 修改文档，指定 id 时再索引一次

- 不同—**新增上**
	- **PUT 新增只能自定义id**，不能自动生成（因为PUT本就是设定用来修改的）
	- **POST 新增可以不带id（自动生成），也可以自定义id**

- 补充
	- PUT修改必须指定文档id、否则报错
	- POST修改若指定存在的文档id，则为修改；若指定不存在或者没有接上文档id，则为新增

### 3.3 查询指定 id 文档

![image-20231125172846736](https://img.haipeng-lin.cn/20251003074506.png)

### 3.4 更新文档

```yml
# 之前就是这种写法：版本直接加
POST customer/external/1
{
  "name": "John Doe2"
}

# 会对比之前的内容，相同则版本不变
POST customer/external/1/_update
{
  "doc": {
    "name": "John Doe2"
  }
}

# 更新同时增加属性
PUT customer/external/1
{
  "name": "John Doe3"
}

# 更新同时增加属性
POST customer/external/1/_update
{
  "doc": {
    "name": "Jane Doe",
    "age": 20
  }
}
```

POST方式一与方式二的区别是否带update

- **带_update的POST更新：会对比源文档数据**， 如果相同不会有什么操作， 文档 version 不增加

- 不带_update的POST：总会将数据重新保存并增加 version 版本

- PUT 操作总会将数据重新保存并增加 version 版本；

### 3.5 删除索引

```yml
#删除文档
DELETE customer/external/1

#删除索引
DELETE customer
```

### 3.6 bulk 批量API

在单个 API 调用中执行多个索引或删除操作。这减少了开销并且可以大大提高索引速度。

#### 3.6.1 语法格式

> { action: { metadata }} //action: 操作; metadata:对哪一个数据进行操作
>
> { request body } //操作的内容
>
> { action: { metadata }}
>
> { request body }
>
> 两个一组

![image-20231125223007146](https://img.haipeng-lin.cn/20251003074512.png)

#### 3.6.2 复杂bulk

```java
POST /_bulk
{ "delete": { "_index": "website", "_type": "blog", "_id": "123" }}
{ "create": { "_index": "website", "_type": "blog", "_id": "123" }}
{ "title": "My first blog post" }
{ "index": { "_index": "website", "_type": "blog" }}				  
{ "title": "My second blog post" }
{ "update": { "_index": "website", "_type": "blog", "_id": "123"}}
{ "doc" : {"title" : "My updated blog post"} }
```

> bulk API 以此按顺序执行所有的 action（动作） 。 如果一个单个的动作因任何原因而失败，它将继续处理它后面剩余的动作。 当 bulk API 返回时， 它将提供每个动作的状态（与发送的顺序相同） ， 所以您可以检查是否一个指定的动作是不是失败了。

## 4.进阶检索

### 4.1 导入数据

- 数据链接：[数据](https://gitee.com/zhourui815/gulimall/blob/master/doc/es%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE.json#)

- 数据录入命令：

  ```
  POST bank/account/_bulk
  测试数据
  ```

### 4.2 SearchAPI

ES 支持两种基本方式检索 :

- 一个是通过使用 REST request URI 发送搜索参数（uri+检索参数）
- 另一个是通过使用 REST request body 来发送它们（uri+请求体）

#### 4.2.1 检索信息

一切检索从_search 开始 

![image-20231125224553112](https://img.haipeng-lin.cn/20251003074521.png)

#### 4.2.2 请求参数方式检索

```yml
# 请求参数方式检索
q=*  代表要查询的字段类似于select *
sort=account_number:asc  代表按照 account_number 字段排序,升序
GET bank/_search?q=*&sort=account_number:asc
```

#### 4.2.3 uri+请求体进行检索

```yml
#uri+请求体进行检索  
GET bank/_search
{
  "query": {
    "match_all": {}
  },
  "sort": [
    {
      "account_number": {
        "order": "desc"
      }
    }
  ]
}
```

### 4.3 Query DSL

Elasticsearch 提供了一个可以执行查询的 Json 风格的 DSL（ domain-specific language 领域特定语言），这个被称为 Query DSL。 

#### 4.3.1 语法格式

```yml
# 一个查询语句 的典型结构
{
	QUERY_NAME: {
	ARGUMENT: VALUE,
	ARGUMENT: VALUE,...
	}
}
# 如果是针对某个字段， 那么它的结构如下：
{
	QUERY_NAME: {
		FIELD_NAME: {
		ARGUMENT: VALUE,
		ARGUMENT: VALUE,...
		}
	}
}
```

#### 4.3.2 查询示例

- 查询 bank 索引并按照 account_number 字段降序排序,分页大小为5

```yml
#基本查询示例
GET bank/_search
{
  "query": {
    "match_all": {}
  },
  "from": 0,
  "size": 5,
  "sort": [
    {
      "account_number": {
        "order": "desc"
      }
    }
  ]
}
```

- query 定义如何查询
- match_all 查询类型【代表查询所有的所有】 ，

#### 4.3.3 match 匹配

- match 返回 account_number=20 的数据

```yml
#match 基本类型(非字符串类型),精确匹配  
GET bank/_search
{
  "query": {
    "match": {
      "account_number": "20"
    }
  }
}
```

- 最终查询出 address 中包含 mill 单词的所有记录 match 当搜索字符串类型的时候， 会进行全文检索， 并且每条记录有相关性得分。

```yml
#match 字符串类型,全文检索，模糊匹配
GET bank/_search
{
  "query": {
    "match": {
      "address": "mill"
    }
  }
}
```

- 最终查询出 address 中包含 mill 或者 road 或者 mill road 的所有记录， 并给出相关性得分

```yml
#match 字符串， 多个单词（ 分词+全文检索）
GET bank/_search
{
  "query": {
    "match": {
      "address": "mill road"
    }
  }
}
```

#### 4.3.4 match_phrase 短语匹配

> 短语匹配：将需要匹配的值当成一个整体单词（ 不分词） 进行检索
>
> 查出 address 中包含 mill road 的所有记录， 并给出相关性得分

```yml
#match_phrase 短语匹配
GET bank/_search
{
  "query": {
    "match_phrase": {
      "address": "mill road"
    }
  }
}
```

#### 4.3.5 multi_match 多字段匹配

> 查询 state 或者 address字段 包含 mill

```yml
#multi_match 多字段匹配
GET bank/_search
{
  "query": {
    "multi_match": {
      "query": "mill",
      "fields": ["address","state"]
    }
  }
}
```

### 4.4 bool 复合查询

bool 用来做复合查询：复合语句可以合并任何其它查询语句，包括复合语句， 复合语句之间可以互相嵌套，可以表达非常复杂的逻辑。

#### 4.4.1 must

- 必须达到 must 列举的所有条件

```yml
# must 必须达到 must 列举的所有条件
GET bank/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "address": "Mill"
          }
        },
        {
          "match": {
            "gender": "M"
          }
        }
      ]
    }
  }
}
```

#### 4.4.2 should

应该达到 should 列举的条件， 如果达到会增加相关文档的评分， 并不会改变查询的结果。

如果 query 中只有 should 且只有一种匹配规则， 那么 should 的条件就会被作为默认匹配条件而去改变查询结果

```yml
# 应该达到 should列举的条件，如果达到会增加相关文档的评分，并不会改变查询的结果。
GET bank/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "address": "mill"
          }
        },
        {
          "match": {
            "gender": "M"
          }
        }
      ],
      "should": [
        {
          "match": {
            "address": "lane"
          }
        }
      ]
    }
  }
}
```

#### 4.4.3 must_not

必须不是指定的情况

address 包含 mill， 并且 gender 是 M， 如果 address 里面有 lane 最好不过， 但是匹配的字段必须不是文本类型

```yml
#must_not 必须不是指定的情况  
GET bank/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "address": "mill"
          }
        },
        {
          "match": {
            "gender": "M"
          }
        }
      ],
      "should": [
        {
          "match": {
            "address": "lane"
          }
        }
      ],
      "must_not": [
        {
        	"match": {
          "FIELD": "TEXT"
        }
        }
      ]
    }
  }
}
```

#### 4.4.4 filter结果过滤

并不是所有的查询都需要产生分数， 特别是那些仅用于 “filtering”（过滤） 的文档。 **为了不计算分数 **Elasticsearch 会自动检查场景并且优化查询的执行。

![image-20231125233601072](https://img.haipeng-lin.cn/20251003074531.png)

#### 4.4.5 小结

|          | 描述                                         |
| -------- | -------------------------------------------- |
| must     | 查询子句必须出现在匹配的文档中，有查询分数   |
| should   | 查询子句应该出现在匹配的文档中               |
| filter   | 查询子句必须出现在匹配的文档中，忽略查询分数 |
| must_not | 查询子句不能出现在匹配的文档中               |

### 4.5 term—非text字段检索

- 和 match 一样。 匹配某个属性的值。 全文检索字段用 match， 其他**非 text 字段**匹配用 term。

```yml
#term 其他非 text 字段检索
GET bank/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "account_number": {
              "value": "970"
            }
          }
        },
        {
          "match": {
            "address": "Mill"
          }
        }
      ]
    }
  }
}
```

### 4.6 aggregations 聚合检索

最简单的聚合方法大致等于 SQL GROUP BY 和 SQL 聚合函数。

在 Elasticsearch 中， 您有执行搜索返回 hits（ 命中结果），并且同时返回聚合结果， 把一个响应中的所有 hits（ 命中结果） 分隔开的能力。 

可以执行查询和多个聚合， 并且在一次使用中得到各自的（ 任何一个的） 返回结果， 使用一次简洁和简化的 API 来避免网络往返。

> 写在前面：有很多种聚合方式：terms、avgs聚合

<img src="https://img.haipeng-lin.cn/20251003074543.png" alt="image-20231126091812312" style="zoom:50%;" />

#### 4.6.1 年龄分布、并求出年龄的平均值

> 搜索 address 中包含 mill 的所有人的年龄分布以及平均年龄， 但不显示这些人的详情（size=0）

<img src="https://img.haipeng-lin.cn/20251003074546.png" alt="image-20231126092304394" style="zoom: 50%;" />



#### 4.6.2 求出年龄分布,并在每个年龄求平均薪资

![image-20231126092648463](https://img.haipeng-lin.cn/20251003074552.png)

### 4.7 Mapping

#### 4.4.1 字段类型

- 字段类型有核心类型、复合类型、地理类型、特定类型以及多字段类型共5种
- **核心类型：**
  - 字符串：string、text、keyword
  - 数字类型：long、integer、short、byte、double、float
  - 日期型：date
  - 布尔类型：boolean
  - 二进制类型：binary

- **复合类型**：数组类型（Array）、对象类型（Object）、嵌套类型（Nested）
- **地理类型**：地理坐标（Geo-points）、地理图形（Geo-Shape）
- **特定类型**：IP类型（ip）、补全类型（Completion）、令牌计数类型（Token count）、附件类型（attachment）
- **多字段类型**：通常用于为不同目的用不同的方法索I同一个字段。例如，**string字段**可以映射为一个text字段用于全文检索，同样可以映射为一个keyword字段用于排序和聚合

#### 4.4.2 映射简介

Mapping 是用来定义一个文档（ document） ， 以及它所包含的属性（ field） 是如何存储和索引的。 比如，使用 mapping 来定义：

- 哪些字符串属性应该被看做全文本属性（full text fields）
- 哪些属性包含数字， 日期或者地理位置
- 文档中的所有属性是否都能被索引

```yml
#查看mapping信息
GET bank/_mapping
```

<img src="https://img.haipeng-lin.cn/20251003074603.png" alt="image-20231126093413138" style="zoom:50%;" />

- 问题：我们在创建索引是没有指定类型，为什么会查询出来呢?
- 答案：es会根据数据自动猜测的映射类型，自动猜测的映射类型有：
	- 布尔型：true或者false，猜测的映射类型为boolean
	- 整数：123，猜测的映射类型为long
	- 浮点数：123.45，猜测的映射类型为double
	- 字符串，有效日期：2024-10-10，猜测的映射类型为date
	- 字符串：foo bar，猜测的映射类型为string



#### 4.4.3 创建映射

![image-20231126094141793](https://img.haipeng-lin.cn/20251003074611.png)

#### 4.4.4 更新映射

对于已经存在的映射字段， 我们不能更新。 更新必须创建新的索引进行数据迁移

#### 4.4.5 数据迁移

##### （1）查询之前的映射

```yml
GET bank/_mapping
```

- 将查询的字段映射复制出来
- 假设age字段类型为long，想换成integer类型

![image-20231126100102484](https://img.haipeng-lin.cn/20251003074617.png)

##### （2）新增一个新索引

将复制的属性粘贴到属性中，先不执行

```json
"account_number" : {
    "type" : "long"
},
"address" : {
    "type" : "text",
    "fields" : {
        "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
        }
    }
},
"age" : {
    "type" : "long"
},
"balance" : {
    "type" : "long"
},
"city" : {
    "type" : "text",
    "fields" : {
        "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
        }
    }
},
"email" : {
    "type" : "text",
    "fields" : {
        "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
        }
    }
},
"employer" : {
    "type" : "text",
    "fields" : {
        "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
        }
    }
},
"firstname" : {
    "type" : "text",
    "fields" : {
        "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
        }
    }
},
"gender" : {
    "type" : "text",
    "fields" : {
        "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
        }
    }
},
"lastname" : {
    "type" : "text",
    "fields" : {
        "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
        }
    }
},
"state" : {
    "type" : "text",
    "fields" : {
        "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
        }
    }
}
```

##### （3）修改映射

```yml
# 创建一个新索引
PUT newbank2
{
  "mappings":{
    "properties": {
    "account_number": {
      "type": "long"
    },
    "address": {
      "type": "text"
    },
    "age": {
      "type": "integer"
    },
    "balance": {
      "type": "long"
    },
    "city": {
      "type": "text",
      "fields": {
        "keyword": {
          "type": "keyword",
          "ignore_above": 256
        }
      }
    },
    "email": {
      "type": "text",
      "fields": {
        "keyword": {
          "type": "keyword",
          "ignore_above": 256
        }
      }
    },
    "employer": {
      "type": "text",
      "fields": {
        "keyword": {
          "type": "keyword",
          "ignore_above": 256
        }
      }
    },
    "firstname": {
      "type": "text",
      "fields": {
        "keyword": {
          "type": "keyword",
          "ignore_above": 256
        }
      }
    },
    "gender": {
      "type": "text",
      "fields": {
        "keyword": {
          "type": "keyword",
          "ignore_above": 256
        }
      }
    },
    "lastname": {
      "type": "text",
      "fields": {
        "keyword": {
          "type": "keyword",
          "ignore_above": 256
        }
      }
    },
    "state": {
      "type": "text",
      "fields": {
        "keyword": {
          "type": "keyword",
          "ignore_above": 256
        }
      }
    }
  }
  }
}
```

##### （4）数据迁移

```yml
#数据迁移
POST _reindex
{
  "source": {
    "index": "bank"
  },
  "dest": {
    "index": "newbank2"
  }
}
```

> 迁移成功

![image-20231126101222331](https://img.haipeng-lin.cn/20251003074625.png)

### 4.8 分词

在ES中，一个 tokenizer（ 分词器） 接收一个字符流， 将之分割为独立的 tokens（ 词元， 通常是独立的单词） ， 然后输出 tokens 流。

例如， whitespace tokenizer 遇到空白字符时分割文本。 它会将文本 “Quick brown fox!” 分割为 [Quick, brown, fox!]。该 tokenizer（分词器） 还负责记录各个 term（词条） 的顺序或 position 位置（用于 phrase 短语和 word proximity 词近邻查询） ， 以及 term（词条） 所代表的原始 word（单词） 的 start（起始） 和 end（结束） 的 character offsets（字符偏移量） （用于高亮显示搜索的内容） 。

Elasticsearch 提供了很多内置的分词器， 可以用来构建 custom analyzers（自定义分词器） 。

#### 4.8.1 安装 ik 分词器

没有安装分词器之前的效果

<img src="https://img.haipeng-lin.cn/20251003074630.png" alt="image-20231126102404692" style="zoom:50%;" />

**注意： 不能用默认 elasticsearch-plugin install xxx.zip 进行自动安装**

- 由于之前映射了plugins目录,所以在/mydata/elasticsearch/plugins/下载elasticsearch-analysis-ik-7.4.2.zip

```
wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.4.2/elasticsearch-analysis-ik-7.4.2.zip
```

- 解压

```
unzip elasticsearch-analysis-ik-7.4.2.zip
```

- 删除zip文件

```
rm –rf *.zip
```

- 将elasticsearch文件夹下的所有文件 移动至ik目录下(自建目录)

**使用xftp进行移动**

![image-20231126110523062](https://img.haipeng-lin.cn/20251003074639.png)

- 修改ik文件夹权限

```yml
chmod -R 777 ik
```

- 确认是否安装好了分词器

```yml
# 进入容器内部
docker exec -it 容器 id /bin/bash
# 切换目录
cd bin
# 列出安装的plugin
elasticsearch plugin list
```

- 发现ik后重启容器

```yml
docker restart elasticsearch
```

#### 4.8.2 测试

- 使用默认分词器

<img src="https://img.haipeng-lin.cn/20251003074643.png" alt="image-20231126110748326" style="zoom:50%;" />

- 使用ik_smart分词器

![image-20231126110816338](https://img.haipeng-lin.cn/20251003074655.png)

- 使用ik_max_word 分词器

![image-20231126110900124](https://img.haipeng-lin.cn/20251003074657.png)

#### 4.8.3 自定义词库

![image-20231126111345748](https://img.haipeng-lin.cn/20251003074705.png)

自定义词库测试

- 创建词库

> **在4.6：搭建好nginx的基础上,搭建nginx在8.x章节**

```
cd /mydata/nginx/html/
#创建自定义词库
vim fenci.txt
```

添加新词

![image-20231126114652319](https://cdn.jsdelivr.net/gh/haipeng-lin/blog-img/202503201651243.png)

- 修改分词器配置文件

```
vim /mydata/elasticsearch/plugins/ik/config/IKAnalyzer.cfg.xml
```

![image-20231126120129228](https://cdn.jsdelivr.net/gh/haipeng-lin/blog-img/202503201651029.png)

- 重启es

```
docker restart elasticsearch
```

- 效果

![image-20231126120246793](https://cdn.jsdelivr.net/gh/haipeng-lin/blog-img/202503201651257.png)

## 5.SpringBoot整合ES

### 5.1 xml配置

SpringBoot想和ES进行通信传递消息的方式有两种：tcp、http

- 9300： TCP
  - 需要的jar包：spring-data-elasticsearch:transport-api.jar；
  - springboot 版本不同， transport-api.jar 不同， 不能适配 es 版本
  - 7.x 已经不建议使用， 8 以后就要废弃

- 9200： HTTP，有以下四种通信方式
  - JestClient： 非官方， 更新慢
  - RestTemplate： 模拟发 HTTP 请求， ES 很多操作需要自己封装， 麻烦
  - HttpClient： 同上
  - Elasticsearch-Rest-Client： 官方 RestClient， 封装了 ES 操作， API 层次分明， 上手简单

```xml
<dependency>
    <groupId>org.elasticsearch.client</groupId>
    <artifactId>elasticsearch-rest-high-level-client</artifactId>
    <version>7.4.2</version>
</dependency>

可能出现bug，换成以下依赖
<dependency>
    <groupId>org.elasticsearch.client</groupId>
    <artifactId>elasticsearch-rest-high-level-client</artifactId>
    <version>7.4.2</version>
    <exclusions>
        <exclusion>
            <groupId>org.elasticsearch</groupId>
            <artifactId>elasticsearch</artifactId>
        </exclusion>
        <exclusion>
            <groupId>org.elasticsearch.client</groupId>
            <artifactId>elasticsearch-rest-client</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.elasticsearch.client</groupId>
    <artifactId>elasticsearch-rest-client</artifactId>
    <version>7.4.2</version>
</dependency>
<dependency>
    <groupId>org.elasticsearch</groupId>
    <artifactId>elasticsearch</artifactId>
    <version>7.4.2</version>
</dependency>
```

### 5.2 配置类

- 主启动类添加注解：@EnableDiscoverClient

- 新增 ES 配置类

<img src="https://img.haipeng-lin.cn/20251003074711.png" alt="image-20231126171821397" style="zoom: 50%;" />

### 5.3 测试连接

<img src="https://img.haipeng-lin.cn/20251003074715.png" alt="image-20231126171840588" style="zoom: 50%;" />

测试结果：

<img src="https://img.haipeng-lin.cn/20251003074719.png" alt="image-20231126171738371" style="zoom: 50%;" />

### 5.4 测试使用

#### 5.4.1 索引记录

<img src="https://img.haipeng-lin.cn/20251003074723.png" alt="image-20231126223459965" style="zoom: 50%;" />

- 测试结果

<img src="https://img.haipeng-lin.cn/20251003074728.png" alt="image-20231126181349680" style="zoom: 50%;" />



#### 5.4.2 获取数据

<img src="https://img.haipeng-lin.cn/20251003074733.png" alt="image-20231126223642236" style="zoom: 50%;" />

```yml
#match 字符串类型全文检索
GET bank/_search
{
  "query": {
    "match": {
      "address": "mill"
    }
  }
}
```

> 两个查询结果相同

#### 5.4.3 聚合查询

<img src="https://img.haipeng-lin.cn/20251003074738.png" alt="image-20231126224123565" style="zoom:50%;" />

<img src="https://img.haipeng-lin.cn/20251003074743.png" alt="image-20231126224024399" style="zoom:50%;" />

#### 5.4.4 结果转为对象

> 具体结果在下面那个hits里

<img src="https://cdn.jsdelivr.net/gh/haipeng-lin/blog-img/202503201652681.png" alt="image-20231126224247804" style="zoom:50%;" />

> 利用json生成javabean,并使用lombok

<img src="https://img.haipeng-lin.cn/20251003074755.png" alt="image-20231126224421195" style="zoom:50%;" />

- 测试

<img src="https://img.haipeng-lin.cn/20251003074758.png" alt="image-20231126224706454" style="zoom: 67%;" />

- 结果

![image-20231126224630489](https://img.haipeng-lin.cn/20251003074802.png)





