---
title: 引用计数缓存框架
createTime: 2025/01/15 23:09:34
permalink: /project/MiniDB/vziofyo4/
---

## 1.设计思路

​		当某个资源被使用到时，就加入到缓存，如果有其他的模块也在访问这个缓存，那么计数就加1，只有当所有的模块都释放了该资源时，将其从缓存中释放

问题：为什么不使用LRU？

因为MiniDB涉及到了回源操作

**回源操作** 指的是将资源刷回数据源，举例：某个时刻缓存满了，缓存驱逐了一个资源，这时上层模块想要将某个资源强制刷回数据源，这个资源恰好是刚刚被驱逐的资源。那么上层模块就发现，这个数据在缓存里消失了

LRU 策略中，资源驱逐不可控，上层模块无法感知。而引用计数策略正好解决了这个问题，只有上层模块主动释放引用，缓存在确保没有模块在使用这个资源了，才会去驱逐资源

## 2.AbstractCache抽象缓存接口

> com.peng.minidb.backend.common.AbstractCache类

### 2.1 缓存结构

- cacheMap<key,value>：缓存实际存储的数据
- referecesMap<key,count>：存储每个资源的引用计数
- getting<key,value>：记录哪些资源当前正在从数据源中获取，key是资源的唯一标识符，value是布尔值，表示该资源是否正在被获取中（多线程环境下可能一个资源被同时获取，而获取的过程较长（如从文件中读取），防止多线程并发问题而引入该map）
- maxResources：缓存的最大资源数，防止内存溢出
- count：当前缓存的资源数
- lock：锁（整个数据缓存的锁）

### 2.2 抽象方法

> 两个方法均由PageCacheImpl（页面缓存）、DataManagerImpl（数据管理）、VersionManagerImpl（版本管理）实现类实现，具体逻辑具体实现

- getForCache(key)：当资源不在缓存时的获取行为
- releaseForCache(key)：当资源被驱逐时的写回行为

### 2.3 重要方法

- get(key)：
	- 作用：从缓存获取指定key的资源过程：
	- 首先，先获取抽象缓存结构的锁，再判断是否有其他线程正在从数据源中获取该资源
		- 有，解锁，睡眠一秒并continue
		- 没有，判断资源是否存在于缓存中
			- 存在，将资源的引用数+1，解锁，直接获取资源并返回
			- 不存在，判断资源总数是否超过最大值，没超过，则在`getting`中标记true，然后该线程从数据源中获取资源，获取到之后标记false，解锁

```java
protected T get(long key) throws Exception {
    while(true) {
        lock.lock();
        // 1、请求的资源正在被其他线程获取
        if(getting.containsKey(key)) {
            lock.unlock();
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
                continue;
            }
            continue;
        }
		// 2、判断资源是否存在于缓存中
        if(cache.containsKey(key)) {
            // 2.1、资源在缓存中，直接返回
            T obj = cache.get(key);
            references.put(key, references.get(key) + 1);
            lock.unlock();
            return obj;
        }

        // 3、尝试获取该资源
        if(maxResource > 0 && count == maxResource) {
            lock.unlock();
            throw Error.CacheFullException;
        }
        count ++;
        getting.put(key, true);
        lock.unlock();
        break;
    }

    T obj = null;
    try {
        obj = getForCache(key);
    } catch(Exception e) {
        lock.lock();
        count --;
        getting.remove(key);
        lock.unlock();
        throw e;
    }

    lock.lock();
    getting.remove(key);
    cache.put(key, obj);
    references.put(key, 1);
    lock.unlock();

    return obj;
}
```

- release(key)：
	- 作用：释放缓存
	- 释放缓存时，将对应的引用计数-1，如果已经减到0了就回源，然后删除缓存中相关的各种数据

```java
/**
 * 强行释放一个缓存
 */
protected void release(long key) {
    lock.lock(); // 获取锁
    try {
        int ref = references.get(key) - 1; // 获取资源的引用计数并减一
        if (ref == 0) { 			// 如果引用计数为0
            T obj = cache.get(key); // 从缓存中获取资源
            releaseForCache(obj); 	// 处理资源的释放
            references.remove(key); // 从引用计数的映射中移除资源
            cache.remove(key); 		// 从缓存中移除资源
            count--; 				// 将缓存中的资源计数减一
        } else { // 如果引用计数不为0
            references.put(key, ref); // 更新资源的引用计数
        }
    } finally {
        lock.unlock(); // 释放锁
    }
}
```

- close()：
	- 作用：关闭缓存
	- 注意，在关闭缓存结构时，所有的缓存资源要强行回源

```java
/**
 * 关闭缓存，写回所有资源
 */
protected void close() {
    lock.lock();
    try {
        //获取所有资源key
        Set<Long> keys = cache.keySet();
        for (long key : keys) {
            //获取缓存
            T obj = cache.get(key);
            //释放缓存
            releaseForCache(obj);
            //引用计数移除缓存
            references.remove(key);
            //实际缓存移除缓存
            cache.remove(key);
        }
    } finally {
        //释放锁
        lock.unlock();
    }
}
```
