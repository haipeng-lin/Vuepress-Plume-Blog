---
title: DM实现
createTime: 2025/01/15 23:10:47
permalink: /project/MiniDB/qlaqzeii/
---
数据管理器是MiniDB中的数据抽象层，负责存储和管理具体的数据内容，并为上层模块提供访问接口：

- **==数据存储和访问==**：`DataItem` 存储了数据的具体内容，以及相关的元数据信息如数据大小和有效标志等
- **==数据修改与事务管理==**：`DataItem` 支持数据的修改操作，并在修改操作前后执行保存原始数据、记录日志等流程，以确保数据修改的原子性和一致性
- **==缓存管理==**：`DataItem` 对象由底层 `DataManager` 缓存管理，使用 `release()` 方法可以释放缓存中的 `DataItem` 对象，以便回收内存资源

## 8.1DataItem数据结构

### 8.1.1数据结构

```
[ValidFlag] [DataSize] [Data]
```

> - **ValidFlag**：1 字节，表示该 `DataItem` 是否有效。删除 `DataItem` 只需将其有效位设置为 0
> - **DataSize**：2 字节，表示 `Data` 部分的长度

```java
public class DataItemImpl implements DataItem {
    private SubArray raw; // 原始数据
    private byte[] oldRaw; // 旧的原始数据
    private DataManagerImpl dm; // 数据管理器
    private long uid; // 唯一标识符
    private Page pg; // 页面对象
}
```

### 8.1.2uid的生成与解析

`DataItem` 在 `DataManager` 中的存储和管理是通过一个唯一标识符 `Uid` 来实现的。这个 `Uid` 是由页面编号 (`pgno`) 和页面内偏移量 (`offset`) 组成的一个 8 字节无符号整数，其中页号和偏移量各占 4 字节。这里以`pgno = 2 和 offset = 0`来演示生成和解析 `Uid` 的详细过程。

 

## 8.2DM关键方法

**数据访问：**data()：返回 `DataItem` 中的数据部分，不进行数据拷贝，直接返回原始数据的引用

```java
@Override
public SubArray data() {
    return new SubArray(raw.raw, raw.start + OF_DATA, raw.end);
}
```

**数据修改前准备**：before()：在修改数据项之前调用，锁定数据项并保存原始数据，以支持事务回滚

```java
@Override
public void before() {
    wLock.lock();
    pg.setDirty(true);
    System.arraycopy(raw.raw, raw.start, oldRaw, 0, oldRaw.length);
}
```

回滚修改：在需要撤销修改时调用，恢复原始数据并解锁数据项

```java
@Override
public void unBefore() {
    System.arraycopy(oldRaw, 0, raw.raw, raw.start, oldRaw.length);
    wLock.unlock();
}
```

## 8.3DM核心方法

### 8.3.1读取数据

​		read()：根据 `Uid` 从缓存中获取 `DataItem`，并校验其有效性

​		`DataItem` 的 `Uid` 是由页号和页内偏移组成的一个 8 字节无符号整数

```java
@Override
public DataItem read(long uid) throws Exception {
    //从缓存页面中读取到DataItemImpl
    DataItemImpl di = (DataItemImpl) super.get(uid); // 若缓存中不存在则调用 getForCache() 方法
    //校验di是否有效
    if (!di.isValid()) {
        // 无效释放缓存
        di.release();
        return null;
    }
    return di;
}
```

### 8.3.2插入数据

​		insert()：在 `PageIndex` 中选择一个合适的页面进行插入操作，记录插入日志，并返回插入位置的偏移。

​		插入的位置和页面信息都是通过页号和偏移量进行管理的

```java
@Override
public long insert(long xid, byte[] data) throws Exception {
    // 将输入的数据包装成DataItem的原始格式
    byte[] raw = DataItem.wrapDataItemRaw(data);
    // 如果数据项的大小超过了页面的最大空闲空间，抛出异常
    if (raw.length > PageX.MAX_FREE_SPACE) {
        throw Error.DataTooLargeException;
    }

    // 初始化一个页面信息对象
    PageInfo pi = null;
    // 尝试5次找到一个可以容纳新数据项的页面
    for (int i = 0; i < 5; i++) {
        // 从页面索引中选择一个可以容纳新数据项的页面
        pi = pIndex.select(raw.length);
        // 如果找到了合适的页面，跳出循环
        if (pi != null) {
            break;
        } else {
            // 如果没有找到合适的页面，创建一个新的页面，并将其添加到页面索引中
            int newPgno = pc.newPage(PageX.initRaw());
            pIndex.add(newPgno, PageX.MAX_FREE_SPACE);
        }
    }
    // 如果还是没有找到合适的页面，抛出异常
    if (pi == null) {
        throw Error.DatabaseBusyException;
    }

    // 初始化一个页面对象
    Page pg = null;
    // 初始化空闲空间大小为0
    int freeSpace = 0;
    try {
        // 获取页面信息对象中的页面
        pg = pc.getPage(pi.pgno);
        // 生成插入日志
        byte[] log = Recover.insertLog(xid, pg, raw);
        // 将日志写入日志文件
        logger.log(log);

        // 在页面中插入新的数据项，并获取其在页面中的偏移量
        short offset = PageX.insert(pg, raw);

        // 释放页面
        pg.release();
        // 返回新插入的数据项的唯一标识符
        return Types.addressToUid(pi.pgno, offset);

    } finally {
        // 将页面重新添加到页面索引中
        if (pg != null) {
            pIndex.add(pi.pgno, PageX.getFreeSpace(pg));
        } else {
            pIndex.add(pi.pgno, freeSpace);
        }
    }
}

/**
 *  返回一个完整的 DataItem 结构数据
 *  dataItem 结构如下：
 *  [ValidFlag] [DataSize] [Data]
 *  ValidFlag 1字节，0为合法，1为非法
 *  DataSize  2字节，标识Data的长度
 * @param raw
 * @return
 */
public static byte[] wrapDataItemRaw(byte[] raw) {
    byte[] valid = new byte[1]; //证明此时为非法数据
    byte[] size = Parser.short2Byte((short)raw.length); //计算数据字节大小
    return Bytes.concat(valid, size, raw); //拼接DataItem 结构数据
}

/**
 * 根据给定的空间大小选择一个 PageInfo 对象。
 *
 * @param spaceSize 需要的空间大小
 * @return 一个 PageInfo 对象，其空闲空间大于或等于给定的空间大小。如果没有找到合适的 PageInfo，返回 null。
 */
public PageInfo select(int spaceSize) {
lock.lock(); // 获取锁，确保线程安全
try {
    int number = spaceSize / THRESHOLD; // 计算需要的空间大小对应的区间编号
    // 此处+1主要为了向上取整
    /*
            1、假需要存储的字节大小为5168，此时计算出来的区间号是25，但是25*204=5100显然是不满足条件的
            2、此时向上取整找到 26，而26*204=5304，是满足插入条件的
         */
    if (number < INTERVALS_NO) number++; // 如果计算出的区间编号小于总的区间数，编号加一
    while (number <= INTERVALS_NO) { // 从计算出的区间编号开始，向上寻找合适的 PageInfo
        if (lists[number].size() == 0) { // 如果当前区间没有 PageInfo，继续查找下一个区间
            number++;
            continue;
        }
        return lists[number].remove(0); // 如果当前区间有 PageInfo，返回第一个 PageInfo，并从列表中移除
    }
    return null; // 如果没有找到合适的 PageInfo，返回 null
} finally {
    lock.unlock(); // 释放锁
}
}

// 定义一个静态方法，用于创建插入日志
public static byte[] insertLog(long xid, Page pg, byte[] raw) {
    // 创建一个表示日志类型的字节数组，并设置其值为LOG_TYPE_INSERT
    byte[] logTypeRaw = {LOG_TYPE_INSERT};
    // 将事务ID转换为字节数组
    byte[] xidRaw = Parser.long2Byte(xid);
    // 将页面编号转换为字节数组
    byte[] pgnoRaw = Parser.int2Byte(pg.getPageNumber());
    // 获取页面的第一个空闲空间的偏移量，并将其转换为字节数组
    byte[] offsetRaw = Parser.short2Byte(PageX.getFSO(pg));
    // 将所有字节数组连接在一起，形成一个完整的插入日志，并返回这个日志
    return Bytes.concat(logTypeRaw, xidRaw, pgnoRaw, offsetRaw, raw);
}

// 将raw插入pg中，返回插入位置
public static short insert(Page pg, byte[] raw) {
    pg.setDirty(true); // 将pg的dirty标志设置为true，表示pg的数据已经被修改
    short offset = getFSO(pg.getData()); // 获取pg的空闲空间偏移量
    System.arraycopy(raw, 0, pg.getData(), offset, raw.length); // 将raw的数据复制到pg的数据中的offset位置
    setFSO(pg.getData(), (short) (offset + raw.length)); // 更新pg的空闲空间偏移量
    return offset; // 返回插入位置
}
```

### 8.3.3关闭DM

​		正常关闭时，执行缓存和日志的关闭流程，并设置第一页的字节校验

```java
@Override
public void close() {
    super.close();
    logger.close();

    PageOne.setVcClose(pageOne);
    pageOne.release();
    pc.close();
}
```

