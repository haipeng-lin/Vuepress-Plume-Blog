---
title: 索引管理器设计与实现
createTime: 2025/01/15 23:21:58
permalink: /project/MiniDB/uhle14v6/
---
## 1.前言

​		索引管理器是 MiniDB 中用于管理B+树索引的模块，为MiniDB提供了基于B+树的聚簇索引功能

​		索引管理器基于数据管理器，即索引数据直接存储在数据库文件中

## 2.B+树节点

### 2.1节点定义

​		B+ 树由多个节点（Node）组成，==每个节点都存储在一条 DataItem 中==。其数据结构如下：

```java
[LeafFlag]
[KeyNumber]
[SiblingUid]
[Son0][Key0][Son1][Key1]...[SonN][KeyN]
```

- **LeafFlag**：标记该节点是否为叶子节点
- **KeyNumber**：该节点中键的数量
- **SiblingUid**：指向兄弟节点在 DM 中的 UID
- **SonN 和 KeyN**：交替存储子节点和键值对。最后一个键值始终为 `MAX_VALUE`，以便于查找

![image.png](https://cdn.nlark.com/yuque/0/2024/png/22115500/1723887530560-08c5efc8-f75c-468d-b22e-3b40e38dc892.png#averageHue=%23ececec&clientId=u2839daa5-186c-4&from=paste&height=271&id=u30a7cafb&originHeight=542&originWidth=2178&originalType=binary&ratio=2&rotation=0&showTitle=false&size=126303&status=done&style=none&taskId=ua691b3ee-6cdb-4b9c-b755-4881aa26d0f&title=&width=1089)

### 2.2 相关函数

#### 2.2.1 基础函数

> setRawIsLeaf 设置是否为叶子节点，1表示是叶子节点，0表示非叶子节点

```java
static void setRawIsLeaf(SubArray raw, boolean isLeaf) {
    if(isLeaf) {
        raw.raw[raw.start + IS_LEAF_OFFSET] = (byte)1;
    } else {
        raw.raw[raw.start + IS_LEAF_OFFSET] = (byte)0;
    }
}
```

#### 2.2.2 生成一个根节点

> 根节点包含两个初始子节点 `left` 和 `right`，以及一个初始键值 `key`

```java
static byte[] newRootRaw(long left, long right, long key)  {
    SubArray raw = new SubArray(new byte[NODE_SIZE], 0, NODE_SIZE);
    setRawIsLeaf(raw, false);
    setRawNoKeys(raw, 2);
    setRawSibling(raw, 0);
    setRawKthSon(raw, left, 0);
    setRawKthKey(raw, key, 0);
    setRawKthSon(raw, right, 1);
    setRawKthKey(raw, Long.MAX_VALUE, 1);
    return raw.raw;
}
```

#### 2.2.3 生成一个空的根节点

```java
static byte[] newNilRootRaw()  {
    SubArray raw = new SubArray(new byte[NODE_SIZE], 0, NODE_SIZE);

    setRawIsLeaf(raw, true);
    setRawNoKeys(raw, 0);
    setRawSibling(raw, 0);

    return raw.raw;
}
```

#### 2.2.4 搜索插入节点位置

> 根据给定的键值，查找对应的 UID。如果未找到，则返回兄弟节点的 UID

```java
public SearchNextRes searchNext(long key) {
    dataItem.rLock();
    try {
        SearchNextRes res = new SearchNextRes();
        int noKeys = getRawNoKeys(raw);
        for(int i = 0; i < noKeys; i ++) {
            long ik = getRawKthKey(raw, i);
            if(key < ik) {
                res.uid = getRawKthSon(raw, i);
                res.siblingUid = 0;
                return res;
            }
        }
        res.uid = 0;
        res.siblingUid = getRawSibling(raw);
        return res;

    } finally {
        dataItem.rUnLock();
    }
}
```

#### 2.2.5 搜索节点

> `leafSearchRange`**方法**：在当前节点内进行范围查找，范围为 `[leftKey, rightKey]`。如果 `rightKey` 大于等于该节点的最大键值，则返回兄弟节点的 UID，方便继续搜索下一个节点

```java
class LeafSearchRangeRes {
    List<Long> uids;
    long siblingUid;
}

public LeafSearchRangeRes leafSearchRange(long leftKey, long rightKey) {
    dataItem.rLock();
    try {
        int noKeys = getRawNoKeys(raw);
        int kth = 0;
        while(kth < noKeys) {
            long ik = getRawKthKey(raw, kth);
            if(ik >= leftKey) {
                break;
            }
            kth ++;
        }
        List<Long> uids = new ArrayList<>();
        while(kth < noKeys) {
            long ik = getRawKthKey(raw, kth);
            if(ik <= rightKey) {
                uids.add(getRawKthSon(raw, kth));
                kth ++;
            } else {
                break;
            }
        }
        long siblingUid = 0;
        if(kth == noKeys) {
            siblingUid = getRawSibling(raw);
        }
        LeafSearchRangeRes res = new LeafSearchRangeRes();
        res.uids = uids;
        res.siblingUid = siblingUid;
        return res;
    } finally {
        dataItem.rUnLock();
    }
}
```

#### 2.2.6 插入节点

```java
public InsertAndSplitRes insertAndSplit(long uid, long key) throws Exception {
    boolean success = false;
    Exception err = null;
    InsertAndSplitRes res = new InsertAndSplitRes();

    dataItem.before();
    try {
        success = insert(uid, key);
        if(!success) {
            res.siblingUid = getRawSibling(raw);
            return res;
        }
        if(needSplit()) {
            try {
                SplitRes r = split();
                res.newSon = r.newSon;
                res.newKey = r.newKey;
                return res;
            } catch(Exception e) {
                err = e;
                throw e;
            }
        } else {
            return res;
        }
    } finally {
        if(err == null && success) {
            dataItem.after(TransactionManagerImpl.SUPER_XID);
        } else {
            dataItem.unBefore();
        }
    }
}
```

## 3.B+树

### 3.1 B+树定义

```java
DataManager dm;			// 数据管理器
long bootUid;			// 根节点uid
DataItem bootDataItem;	// 根节点数据项
Lock bootLock
```

这里的`BootUid`和`BootDataItem`对应的是B+树的根节点uid和根节点uid对应的`DataItem`

### 3.2 相关函数

#### 3.2.1 创建B+树

```java
public static long create(DataManager dm) throws Exception {
    // 生成一个空的根节点
    byte[] rawRoot = Node.newNilRootRaw();
    // 往数据文件插入根节点数据
    long rootUid = dm.insert(TransactionManagerImpl.SUPER_XID, rawRoot);
    // 
    return dm.insert(TransactionManagerImpl.SUPER_XID, Parser.long2Byte(rootUid));
}
```

#### 3.2.2 加载B+树

```java
public static BPlusTree load(long bootUid, DataManager dm) throws Exception {
    DataItem bootDataItem = dm.read(bootUid);
    assert bootDataItem != null;
    BPlusTree t = new BPlusTree();
    t.bootUid = bootUid;
    t.dm = dm;
    t.bootDataItem = bootDataItem;
    t.bootLock = new ReentrantLock();
    return t;
}
```

#### 3.2.3 获取根节点的uid

```java
private long rootUid() {
    bootLock.lock();
    try {
        SubArray sa = bootDataItem.data();
        return Parser.parseLong(Arrays.copyOfRange(sa.raw, sa.start, sa.start+8));
    } finally {
        bootLock.unlock();
    }
}
```

#### 3.2.4 更新根节点的uid

```java
private void updateRootUid(long left, long right, long rightKey) throws Exception {
    bootLock.lock();
    try {
        byte[] rootRaw = Node.newRootRaw(left, right, rightKey);
        long newRootUid = dm.insert(TransactionManagerImpl.SUPER_XID, rootRaw);
        bootDataItem.before();
        SubArray diRaw = bootDataItem.data();
        System.arraycopy(Parser.long2Byte(newRootUid), 0, diRaw.raw, diRaw.start, 8);
        bootDataItem.after(TransactionManagerImpl.SUPER_XID);
    } finally {
        bootLock.unlock();
    }
}
```

#### 3.2.5 从一个节点开始搜索下一个节点

```java
private long searchNext(long nodeUid, long key) throws Exception {
    while(true) {
        Node node = Node.loadNode(this, nodeUid);
        SearchNextRes res = node.searchNext(key);
        node.release();
        if(res.uid != 0) return res.uid;
        nodeUid = res.siblingUid;
    }
}
```

#### 3.2.6 搜索节点

```java
private long searchLeaf(long nodeUid, long key) throws Exception {
    Node node = Node.loadNode(this, nodeUid);
    boolean isLeaf = node.isLeaf();
    node.release();

    if(isLeaf) {
        return nodeUid;
    } else {
        long next = searchNext(nodeUid, key);
        return searchLeaf(next, key);
    }
}
```

#### 3.2.7 插入数据

```java
public void insert(long key, long uid) throws Exception {
    long rootUid = rootUid();
    InsertRes res = insert(rootUid, uid, key);
    assert res != null;
    if(res.newNode != 0) {
        updateRootUid(rootUid, res.newNode, res.newKey);
    }
}
private InsertRes insert(long nodeUid, long uid, long key) throws Exception {
    Node node = Node.loadNode(this, nodeUid);
    boolean isLeaf = node.isLeaf();
    node.release();

    InsertRes res = null;
    if(isLeaf) {
        res = insertAndSplit(nodeUid, uid, key);
    } else {
        long next = searchNext(nodeUid, key);
        InsertRes ir = insert(next, uid, key);
        if(ir.newNode != 0) {
            res = insertAndSplit(nodeUid, ir.newNode, ir.newKey);
        } else {
            res = new InsertRes();
        }
    }
    return res;
}
```

#### 3.2.8 关闭B+树

```java
public void close() {
    bootDataItem.release();
}
```

