---
title: 会话上下文记忆与会话隔离
createTime: 2025/12/20 23:52:15
permalink: /AI/b8f8ps62/
---


## 概述

大模型是不具备记忆能力，要想让大模型记住之前聊天的内容，唯一的办法就是把之前聊天的内容与新的提示词一起发给大模型。



容器管理机制，充当ChatMessage容器，对ChatMessage进行管理。
淘汰机制（Eviction policy），为保证ChatMessage不会过多。
持久化机制（Persistence），防止聊天上下文丢失的问题。
消息特殊处理机制
SystemMessage特殊处理。
函数调用返回消息特殊处理。



### ChatMemory源码

```java
public interface ChatMemory {
    // ChatMemory 的 ID
    Object id();
   
    // 将 message 添加到 ChatMemory 中
    void add(ChatMessage message);

    // 从ChatMemory中获取消息，怎么取取决于实现
    List<ChatMessage> messages();
    
    // 清空ChatMemory中的消息
    void clear();
}
```

## 动手实操

我们可以采用本地记忆、Redis缓存、MySQL存储来存储聊天信息，下面我们使用 Redis 来实现会话上下文记忆和会话隔离功能

### Redis 工具类

Redis 工具类封装了缓存对象的基本操作

```java title="RedisCache"
@Component
public class RedisCache {

    @Autowired
    public RedisTemplate redisTemplate;

    /**
     * 缓存基本的对象，Integer、String、实体类等
     *
     * @param key   缓存的键值
     * @param value 缓存的值
     */
    public <T> void setCacheObject(final String key, final T value) {
        redisTemplate.opsForValue().set(key, value);
    }

    /**
     * 缓存基本的对象，Integer、String、实体类等
     *
     * @param key      缓存的键值
     * @param value    缓存的值
     * @param timeout  时间
     * @param timeUnit 时间颗粒度
     */
    public <T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit) {
        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);
    }

    /**
     * 设置有效时间
     *
     * @param key     Redis键
     * @param timeout 超时时间
     * @return true=设置成功；false=设置失败
     */
    public boolean expire(final String key, final long timeout) {
        return expire(key, timeout, TimeUnit.SECONDS);
    }

    /**
     * 设置有效时间
     *
     * @param key     Redis键
     * @param timeout 超时时间
     * @param unit    时间单位
     * @return true=设置成功；false=设置失败
     */
    public boolean expire(final String key, final long timeout, final TimeUnit unit) {
        return redisTemplate.expire(key, timeout, unit);
    }

    /**
     * 获取有效时间
     *
     * @param key Redis键
     * @return 有效时间
     */
    public long getExpire(final String key) {
        return redisTemplate.getExpire(key);
    }

    /**
     * 判断 key是否存在
     *
     * @param key 键
     * @return true 存在 false不存在
     */
    public Boolean hasKey(String key) {
        return redisTemplate.hasKey(key);
    }

    /**
     * 获得缓存的基本对象。
     *
     * @param key 缓存键值
     * @return 缓存键值对应的数据
     */
    public <T> T getCacheObject(final String key) {
        ValueOperations<String, T> operation = redisTemplate.opsForValue();
        return operation.get(key);
    }

    /**
     * 删除单个对象
     *
     * @param key
     */
    public boolean deleteObject(final String key) {
        return redisTemplate.delete(key);
    }

    /**
     * 删除集合对象
     *
     * @param collection 多个对象
     * @return
     */
    public boolean deleteObject(final Collection collection) {
        return redisTemplate.delete(collection) > 0;
    }

    /**
     * 缓存List数据
     *
     * @param key      缓存的键值
     * @param dataList 待缓存的List数据
     * @return 缓存的对象
     */
    public <T> long setCacheList(final String key, final List<T> dataList) {
        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);
        return count == null ? 0 : count;
    }

    /**
     * 获得缓存的list对象
     *
     * @param key 缓存的键值
     * @return 缓存键值对应的数据
     */
    public <T> List<T> getCacheList(final String key) {
        return redisTemplate.opsForList().range(key, 0, -1);
    }

    /**
     * 缓存Set
     *
     * @param key     缓存键值
     * @param dataSet 缓存的数据
     * @return 缓存数据的对象
     */
    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet) {
        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);
        Iterator<T> it = dataSet.iterator();
        while (it.hasNext()) {
            setOperation.add(it.next());
        }
        return setOperation;
    }

    /**
     * 获得缓存的set
     *
     * @param key
     * @return
     */
    public <T> Set<T> getCacheSet(final String key) {
        return redisTemplate.opsForSet().members(key);
    }

    /**
     * 缓存Map
     *
     * @param key
     * @param dataMap
     */
    public <T> void setCacheMap(final String key, final Map<String, T> dataMap) {
        if (dataMap != null) {
            redisTemplate.opsForHash().putAll(key, dataMap);
        }
    }

    /**
     * 获得缓存的Map
     *
     * @param key
     * @return
     */
    public <T> Map<String, T> getCacheMap(final String key) {
        return redisTemplate.opsForHash().entries(key);
    }

    /**
     * 往Hash中存入数据
     *
     * @param key   Redis键
     * @param hKey  Hash键
     * @param value 值
     */
    public <T> void setCacheMapValue(final String key, final String hKey, final T value) {
        redisTemplate.opsForHash().put(key, hKey, value);
    }

    /**
     * 获取Hash中的数据
     *
     * @param key  Redis键
     * @param hKey Hash键
     * @return Hash中的对象
     */
    public <T> T getCacheMapValue(final String key, final String hKey) {
        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();
        return opsForHash.get(key, hKey);
    }

    /**
     * 获取多个Hash中的数据
     *
     * @param key   Redis键
     * @param hKeys Hash键集合
     * @return Hash对象集合
     */
    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys) {
        return redisTemplate.opsForHash().multiGet(key, hKeys);
    }

    /**
     * 删除Hash中的某条数据
     *
     * @param key  Redis键
     * @param hKey Hash键
     * @return 是否成功
     */
    public boolean deleteCacheMapValue(final String key, final String hKey) {
        return redisTemplate.opsForHash().delete(key, hKey) > 0;
    }

    /**
     * 获得缓存的基本对象列表
     *
     * @param pattern 字符串前缀
     * @return 对象列表
     */
    public Collection<String> keys(final String pattern) {
        return redisTemplate.keys(pattern);
    }
}

```

### Redis 配置类

为了避免存储到 Redis 的对象乱码，我们需要对存储到 Redis 的 key 和 value 进行 String 序列化

```java title="RedisConfig"
@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);

        // 使用 String 序列化器
        StringRedisSerializer stringSerializer = new StringRedisSerializer();

        // Key 采用 String 序列化
        template.setKeySerializer(stringSerializer);
        template.setHashKeySerializer(stringSerializer);

        // Value 也采用 String 序列化
        template.setValueSerializer(stringSerializer);
        template.setHashValueSerializer(stringSerializer);

        template.afterPropertiesSet();
        return template;
    }
}
```

### Redis 记忆存储

实现 ChatMemoryStore 接口，并实现 getMessages 、updateMessages 、deleteMessages 方法

```java title="RedisChatMemoryStore"
@Service
public class RedisChatMemoryStore implements ChatMemoryStore {

    @Autowired
    private RedisCache redisCache;

    private static final String CHAT_MEMORY_PREFIX = "ai:chat:memory:";

    @Override
    public List<ChatMessage> getMessages(Object memoryId) {
        String key = getCacheKey(memoryId);
        String json = redisCache.getCacheObject(key);
        if (json == null || json.isEmpty()) {
            return new ArrayList<>();
        }
        // 将 JSON 字符串反序列化为对象
        return ChatMessageDeserializer.messagesFromJson(json);
    }

    @Override
    public void updateMessages(Object memoryId, List<ChatMessage> messages) {
        String key = getCacheKey(memoryId);
        // 将对象序列化为 JSON 字符串
        String json = ChatMessageSerializer.messagesToJson(messages);
        redisCache.setCacheObject(key, json);
    }

    @Override
    public void deleteMessages(Object memoryId) {
        redisCache.deleteObject(getCacheKey(memoryId));
    }

    private String getCacheKey(Object memoryId) {
        return CHAT_MEMORY_PREFIX + memoryId.toString();
    }
}
```

### 配置 ChatMemoryProvider

```java title="OpenAiService"
@AiService(wiringMode = EXPLICIT,
        chatModel = "openAiChatModel",
        streamingChatModel = "openAiStreamingChatModel",
        chatMemoryProvider = "chatMemoryProvider"  // [!code ++]
)
public interface OpenAiService {

    @SystemMessage("提示词：你是一名老师")
    String chat(String message);

    @SystemMessage("你是一名智能客服")
    String chatWithRag(String message);

    @SystemMessage("你是一名AI购物助手，根据用户的提问帮助用户搜索相关的商品信息")
    Flux<String> chatWhitStream(String message);

    @SystemMessage("你是一名解答难题的小助手")	// [!code ++]
    Flux<String> chatWithStreamMemory(@MemoryId String memoryId, @UserMessage String message);	// [!code ++]
}
```

### 测试

模拟两个用户和大模型对话：

**第一个用户：**

```
http://localhost:8080/api/chat/stream/memory/1?message=你好呀，我是来自揭阳，喜欢摄影，爬山的小菜鱼，你是谁呀
```

结果：

![image-20251219164037160](https://img.haipeng-lin.cn/1766133637418.png)

测试是否具有记忆功能：

```
http://localhost:8080/api/chat/stream/memory/1?message=我是谁
```

响应结果，已经具有记忆

![image-20251219164122433](https://img.haipeng-lin.cn/1766133682582.png)

**第二个用户**：

```
http://localhost:8080/api/chat/stream/memory/2?message=我是谁
```

响应结果：

![image-20251219164059564](https://img.haipeng-lin.cn/1766133659713.png)
